<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Gesture 3D Cat Interaction</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* 顯示攝像頭畫面 
           1. display: block 顯示
           2. object-fit: cover 填滿畫面
           3. transform: scaleX(-1) 左右鏡像翻轉，讓操作符合直覺
        */
        #input_video {
            display: block; 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 0; /* 放在最底層 */
        }

        /* Canvas for Three.js */
        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
            z-index: 1; /* 放在影片上面 */
            pointer-events: none; /* 讓點擊事件穿透（雖然這裡沒用到滑鼠點擊） */
        }

        /* Loading Overlay */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            transition: opacity 0.5s;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #00d2ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            z-index: 5;
            pointer-events: none;
        }

        h1 { margin: 0 0 5px 0; font-size: 1.2rem; color: #40C9A2; } /* Update Title Color */
        p { margin: 0; font-size: 0.9rem; color: #ccc; }
        
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ff3333;
            margin-right: 8px;
        }
        .status-active { background-color: #A3F7B5; } /* Update Active Color */

    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <div>Initializing Cat Interaction...</div>
            <div style="font-size: 0.8em; margin-top: 10px; color: #888;">Please allow camera access</div>
        </div>

        <div id="ui-layer">
            <h1>Neon Cats VR</h1>
            <p><span id="status-dot" class="status-dot"></span><span id="status-text">Waiting for camera...</span></p>
            <p style="margin-top:5px; font-size: 0.8rem;">Show your hand to play with cats!</p>
        </div>

        <!-- 攝像頭畫面 -->
        <video id="input_video"></video>
        <!-- 3D 畫面 -->
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        // --- 1. Three.js Setup ---
        const canvas = document.getElementById('output_canvas');
        const scene = new THREE.Scene();
        // 移除霧氣效果，或者減淡它，讓背景影片看得清楚
        // scene.fog = new THREE.FogExp2(0x1a1a1a, 0.02); 
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true }); // alpha: true 很重要，讓背景透明
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0x40C9A2, 1, 40); // Update Light Color
        scene.add(pointLight); 

        // Objects Array
        const cats = [];
        const catCount = 5; // 1. 數量減少至 5 隻
        // 3. 更新顏色盤
        const colors = [0xE5F9E0, 0xA3F7B5, 0x40C9A2, 0x2F9C95];

        // --- 製作貓貓模型的函數 ---
        function createCatMesh(color) {
            const group = new THREE.Group();
            
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                flatShading: false, 
                shininess: 80
            });

            // 1. 貓頭 (Head) - 放大尺寸 (半徑 3.0)
            const headGeo = new THREE.SphereGeometry(3.0, 48, 48); 
            const head = new THREE.Mesh(headGeo, material);
            group.add(head);

            // 2. 貓耳 (Ears) - 放大尺寸
            const earGeo = new THREE.ConeGeometry(1.2, 2.4, 32); 
            
            // 左耳 (位置相應調整)
            const leftEar = new THREE.Mesh(earGeo, material);
            leftEar.position.set(-1.8, 2.5, 0); // 調整耳朵位置
            leftEar.rotation.z = 0.5;
            leftEar.rotation.y = -0.2;
            group.add(leftEar);

            // 右耳 (位置相應調整)
            const rightEar = new THREE.Mesh(earGeo, material);
            rightEar.position.set(1.8, 2.5, 0); // 調整耳朵位置
            rightEar.rotation.z = -0.5;
            rightEar.rotation.y = 0.2;
            group.add(rightEar);

            return group;
        }

        
        // 產生貓貓
        for(let i=0; i<catCount; i++) {
            const color = colors[Math.floor(Math.random() * colors.length)];
            const cat = createCatMesh(color);
            
            // Random position spread
            cat.position.x = (Math.random() - 0.5) * 30;
            cat.position.y = (Math.random() - 0.5) * 20;
            cat.position.z = (Math.random() - 0.5) * 10;
            
            // 隨機旋轉
            cat.rotation.x = Math.random() * Math.PI;
            cat.rotation.y = Math.random() * Math.PI;

            // Custom properties for physics
            cat.userData = {
                velocity: new THREE.Vector3(0, 0, 0),
                originalPos: cat.position.clone(),
                rotationSpeed: new THREE.Vector3(
                    (Math.random()-0.5)*0.05, 
                    (Math.random()-0.5)*0.05, 
                    (Math.random()-0.5)*0.05
                )
            };

            scene.add(cat);
            cats.push(cat);
        }

        // The "Hand" Cursor
        // 讓游標稍微大一點，並根據狀態變色
        const cursorGeo = new THREE.SphereGeometry(0.5, 32, 32);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0x40C9A2, transparent: true, opacity: 0.8 });
        const handCursor = new THREE.Mesh(cursorGeo, cursorMat);
        scene.add(handCursor);
        
        // --- 2. Interaction Logic ---
        
        let isPinching = false; // 是否正在捏合
        let draggedCat = null;  // 目前抓著的貓

        function updateCursor(x, y) {
            // ... conversion logic ...
            const vector = new THREE.Vector3();
            // Map 0..1 to -1..1 range (NDC)
            vector.set((1.0 - x) * 2 - 1, -(y * 2 - 1), 0.5);
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const zTarget = 0; 
            const aspect = window.innerWidth / window.innerHeight;
            const visibleHeight = 2 * Math.tan((camera.fov * Math.PI / 180) / 2) * (camera.position.z - zTarget);
            const visibleWidth = visibleHeight * aspect;

            handCursor.position.x = ((1.0 - x) - 0.5) * visibleWidth;
            handCursor.position.y = -(y - 0.5) * visibleHeight;
            handCursor.position.z = zTarget;

            // Visual feedback for pinching
            if (isPinching) {
                handCursor.material.color.setHex(0xFFFFFF); // Pinching = White
                handCursor.scale.set(0.8, 0.8, 0.8);
            } else {
                handCursor.material.color.setHex(0x40C9A2); // Normal = Green
                handCursor.scale.set(1, 1, 1);
            }

            // Move light with cursor
            pointLight.position.copy(handCursor.position);
            pointLight.position.z += 5;
        }

        function checkCollisions() {
            // 4. 改良互動：抓取邏輯 (Pinch to Grab)
            
            if (isPinching) {
                if (draggedCat) {
                    // 如果已經抓著貓，讓它跟隨手部
                    const followForce = handCursor.position.clone().sub(draggedCat.position).multiplyScalar(0.15); // 大貓比較重，稍微減低跟隨力度
                    draggedCat.userData.velocity.add(followForce);
                    
                    draggedCat.userData.velocity.multiplyScalar(0.8); 

                    // 【新增】關鍵修改：在拖動時，持續更新貓貓的「原位」
                    // 這樣放手時，它就會停在新的位置，而不是彈回舊位置
                    draggedCat.userData.originalPos.copy(draggedCat.position);

                } else {
                    // 如果沒抓著，尋找最近的貓來抓
                    let closestDist = Infinity;
                    let candidate = null;
                    
                    cats.forEach(cat => {
                        const dist = handCursor.position.distanceTo(cat.position);
                        // 增加抓取判定範圍，因為貓變大了 (4.0 -> 7.0)
                        if (dist < 7.0 && dist < closestDist) { 
                            closestDist = dist;
                            candidate = cat;
                        }
                    });
                    
                    if (candidate) {
                        draggedCat = candidate;
                        // 視覺反饋
                        candidate.children.forEach(c => c.material.emissive.setHex(0x444444));
                    }
                }
            } else {
                // 放開手
                if (draggedCat) {
                    draggedCat.children.forEach(c => c.material.emissive.setHex(0x000000));
                    draggedCat = null;
                }

                // 普通推開邏輯 (Push)
                cats.forEach(cat => {
                    const dist = handCursor.position.distanceTo(cat.position);
                    // 增加推動判定範圍 (3.5 -> 6.5)
                    const minDist = 6.5;

                    if (dist < minDist) {
                        const pushDir = cat.position.clone().sub(handCursor.position).normalize();
                        const force = (minDist - dist) * 0.8;
                        cat.userData.velocity.add(pushDir.multiplyScalar(force));
                    }
                });
            }
        }

        function updatePhysics() {
            cats.forEach(cat => {
                // Apply velocity
                cat.position.add(cat.userData.velocity);
                
                // Add rotation based on velocity
                cat.rotation.x += cat.userData.rotationSpeed.x + (cat.userData.velocity.y * 0.05);
                cat.rotation.y += cat.userData.rotationSpeed.y + (cat.userData.velocity.x * 0.05);

                // Damping (摩擦力)
                cat.userData.velocity.multiplyScalar(0.92);

                // Spring force back (如果沒被抓，慢慢飄回原位)
                if (cat !== draggedCat) {
                    const returnForce = cat.userData.originalPos.clone().sub(cat.position).multiplyScalar(0.03);
                    cat.userData.velocity.add(returnForce);
                }
            });
        }

        function updatePhysics() {
            cats.forEach(cat => {
                // Apply velocity
                cat.position.add(cat.userData.velocity);
                
                // Add rotation based on velocity (tumble effect)
                cat.rotation.x += cat.userData.rotationSpeed.x + (cat.userData.velocity.y * 0.05);
                cat.rotation.y += cat.userData.rotationSpeed.y + (cat.userData.velocity.x * 0.05);

                // Damping
                cat.userData.velocity.multiplyScalar(0.92);

                // Spring force back
                const returnForce = cat.userData.originalPos.clone().sub(cat.position).multiplyScalar(0.03);
                cat.userData.velocity.add(returnForce);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            checkCollisions();
            updatePhysics();
            renderer.render(scene, camera);
        }
        
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        // --- 3. MediaPipe Hands Setup ---
        
        const videoElement = document.getElementById('input_video');
        const loadingScreen = document.getElementById('loading');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');

        function onResults(results) {
            if (loadingScreen.style.opacity !== '0') {
                loadingScreen.style.opacity = '0';
                setTimeout(() => loadingScreen.style.display = 'none', 500);
                statusText.innerText = "Camera Active!";
                statusDot.classList.add('status-active');
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 獲取食指指尖 (8) 和 拇指指尖 (4)
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];
                
                // 計算兩指距離 (2D 螢幕空間距離)
                const dx = indexTip.x - thumbTip.x;
                const dy = indexTip.y - thumbTip.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // 判斷是否捏合 (閾值設為 0.08，可視情況調整)
                isPinching = dist < 0.08;

                updateCursor(indexTip.x, indexTip.y);
                
                // 更新 UI 狀態文字
                if (isPinching) {
                    statusText.innerText = draggedCat ? "Dragging Cat!" : "Pinching (Grab Mode)";
                } else {
                    statusText.innerText = "Open Hand (Push Mode)";
                }

                handCursor.visible = true;
            } else {
                isPinching = false;
                if(draggedCat) draggedCat = null;
                // statusText.innerText = "No Hand";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraUtils.start()
            .then(() => {
                console.log("Camera started");
            })
            .catch(err => {
                console.error(err);
                statusText.innerText = "Error: Camera access denied";
            });

    </script>
</body>
</html>
